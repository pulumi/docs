const parse = require("node-html-parser");
const fs = require('fs');
const path = require('path');

/**
 * Recursively search for HTML files and add them to the result list.
 *
 * @param {string[]} files A list of files to search through.
 * @param {string[]} result A list of complete file paths to HTML files.
 */
function fetchFilePaths(files, result = []) {
    // Return if the file list is empty.
    if (!files || files.length === 0) {
        return;
    }

    // Grab the first file in the list and build its full path.
    const file = files[0];
    const filePath = path.resolve(__dirname, file);

    // Get the "stat" for the file to check if it is a directory.
    const fstat = fs.statSync(filePath);

    // Split the file string to capture the file suffix.
    const fileParts = file.split(".");
    const fileSuffix = fileParts[fileParts.length - 1];

    // If the file is a directory, check the contents of the directory.
    if (fstat.isDirectory()) {
        const dirFiles = fs.readdirSync(filePath).map(function(file) {
            return path.join(filePath, file);
        });
        files[0] = dirFiles;

        // Add the contents of the directory to the original file list.
        const combinedFiles = [].concat.apply([], files);
        return fetchFilePaths(combinedFiles, result);
    }

    // If the file has a "html" suffix add it the result list.
    if (fileSuffix.toLowerCase() === "html") {
        // Check for autogenerated files.
        const htmlString = fs.readFileSync(filePath, "utf8");
        const autoGeneratedString = "<!-- WARNING: this was generated by a tool. Do not edit it by hand. -->";

        if (htmlString.indexOf(autoGeneratedString) === -1) {
            result.push(filePath);
        }
    }
    const remainingFiles = files.slice(1, files.length);

    // If there are files remaining check them.
    if (remainingFiles.length > 0) {
        return fetchFilePaths(remainingFiles, result);
    }

    // Return the resulting list of HTML files.
    return result;
}

/**
 * Grab the initial list of files in the defined directory and pass them
 * to recursive function to build the file list.
 *
 * @param {string} directoryPath The path relative to the script where the files that need to be checked live.
*/
function buildFileList(directoryPath) {
    const files = fs.readdirSync(path.resolve(__dirname, directoryPath)).map(function(file) {
        return path.join(directoryPath, file);
    });

    return fetchFilePaths(files, []);
}

/**
 * Find the line number of the first occurance of a string in a large string (i.e. HTML).
 * Returns 0 if the string is not found.
 *
 * @param {string} blockText The block of text you want to find a strings line number for.
 * @param {string} string The string you want to find the line number for.
 */
function getLinePosition(blockText, string) {
    // Find the starting index of the string in the block.
    const stringIndex = blockText.indexOf(string);

    // Return zero if the string is not found.
    if (stringIndex === -1) {
        return 0;
    }

    // Grab everything leading up the start of the specified string.
    const shortenedBlock = blockText.substr(0, stringIndex);

    // Split the shortened block by '\n' and return the length of the array.
    return shortenedBlock.split("\n").length;
}

const DATA_TRACKING_ID_REGEX = /data-tracking-id=("|')([a-zA-Z0-9]+)([-{ ()$.a-zA-Z0-9}]+)("|')/g;

/**
 * Convert an element from the HTML parse result to a validation object
 * for our tests.
 *
 * @param {object} link An HTML <a> element.
 */
const validateTrackingLink = function(html) {
    return function(link) {
        // Grab the tracking id.
        const trackingIdMatches = link.rawAttrs.match(DATA_TRACKING_ID_REGEX);
        const trackingIdString = trackingIdMatches && trackingIdMatches.length > 0 && trackingIdMatches[0];

        // Get the tracking id value.
        let trackingId = "";
        if (trackingIdString) {
            const rawIdValue = trackingIdString.split("=")[1];
            trackingId = rawIdValue.replace(`/("|')/g`, "");
        }

        const isValidId = (trackingIdString)
                        && (trackingId && trackingId.trim().length > 0);
        // Return an object that checks the element is a link and the
        // track-click attribute is present.
        if (!isValidId) {
            const hmtlLink = `<a ${link.rawAttrs}>`;
            return {
                id: trackingId && trackingId.trim(),
                rawAttrs: link.rawAttrs,
                validId: isValidId,
                linePosition: getLinePosition(html, hmtlLink),
            };
        }
        return null;
    }
};

// Build a list of files to lint from the layouts directory.
const filesToLint = buildFileList("../layouts");

const linkLintErrors = {};

for (let i = 0; i < filesToLint.length; i++) {
    const fileToLint = filesToLint[i];
    const html = fs.readFileSync(fileToLint, "utf8");
    const parsedHtml = parse.parse(html);
    const links = parsedHtml.querySelectorAll("a").map(validateTrackingLink(html))
                  .filter(function(result) { return result !== null });
    if (links.length > 0) {
        linkLintErrors[fileToLint] = links;
    }
}

const filesWithErrors = Object.keys(linkLintErrors);

function createErrorOutput(error) {
    let msg = "";
    if (!error.validId) {
        msg += "Link missing 'data-tracking-id' attribute.";
    }
    msg += "\n";
    return msg;
}

const errorOutput = filesWithErrors.map(function(file) {
    const errors = linkLintErrors[file];
    let errorAmount = 0;
    const errorList = errors.map(function(err, i) {
        const errMsg = createErrorOutput(err);
        errorAmount = i + 1;
        return `    Line ${err.linePosition}: ${errMsg}`;
    }).join("");
    return(`\n` +
        `${file} has ${errorAmount} errors:\n` +
        `${errorList}` +
    ``);
}).join("");

if (filesWithErrors.length > 0) {
    console.log(`\n` +
        `Link Lint Result:\n` +
            `- ${filesToLint.length} files parsed.\n` +
            `- ${filesWithErrors.length} files have errors.\n\n` +
        `ERRORS:\n` +
            `${errorOutput}\n` +
        `${[].concat.apply([], Object.values(linkLintErrors)).length} lint errors.` +
    `\n`);

    const noError = process.argv.indexOf("--no-error") > -1;
    process.exit(noError ? 0 : 1);
}

console.log(`
\nLink Lint Result:
    - ${filesToLint.length} files parsed.
    - 0 errors found.\n
`);
process.exit(0);
