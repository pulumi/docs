const parse = require("node-html-parser");
const fs = require('fs');
const path = require('path');

/**
 * Recursively search for html files and add them to the result list.
 *
 * @param {string[]} files A list of files to search through.
 * @param {string[]} result A list of complete file paths to html files.
 */
function fetchFilePaths(files, result = []) {
    // Grab the first file in the list and build its full path.
    const file = files[0];
    const filePath = path.resolve(__dirname, file);

    // Get the "stat" for the file to check if it is a directory.
    const fstat = fs.statSync(filePath);

    // Split the file string to capture the file suffix.
    const fileParts = file.split(".");
    const fileSuffix = fileParts[fileParts.length - 1];

    // If the file is a directory, check the contents of the directory.
    if (fstat.isDirectory()) {
        const dirFiles = fs.readdirSync(filePath).map(function(file) {
            return filePath + "/" + file;
        });
        files[0] = dirFiles;

        // Add the contents of the directory to the original file list.
        const combinedFiles = [].concat.apply([], files);
        return fetchFilePaths(combinedFiles, result);
    }else {
        // If the file has a "html" suffix add it the result list.
        if (fileSuffix.toLowerCase() === "html") {
            // Check for autogenerated files.
            const htmlString = fs.readFileSync(filePath, "utf8");
            const autoGeneratedString = "<!-- WARNING: this was generated by a tool. Do not edit it by hand. -->";

            if (htmlString.indexOf(autoGeneratedString) === -1) {
                result.push(filePath);
            }
        }
        const remainingFiles = files.slice(1, files.length);

        // If there are files remaining check them.
        if (remainingFiles.length > 0) {
            return fetchFilePaths(remainingFiles, result);
        }
    }

    // Return the resulting list of html files.
    return result;
}

/**
 * Grab the initial list of files in the defined directory and pass them
 * to recursive function to build the file list.
 *
 * @param {string} directoryPath The path relative to the script where the files that need to be checked live.
*/
function buildFileList(directoryPath) {
    const files = fs.readdirSync(path.resolve(__dirname, directoryPath)).map(function(file) {
        return directoryPath + "/" + file;
    });

    return fetchFilePaths(files, []);
}

/**
 * Convert an element from the HTML parse result to a validation object
 * for our tests.
 *
 * @param {object} link An HTML <a> element.
 */
function validateTrackingLink(link) {
    console.log(link);
    const isValid = (link.id && link.tagName === "a")
                    && (link.rawAttrs.indexOf("track-click") > -1)
                    && (link.id && link.id.trim().length > 0);
    // Return an objec that checks the element is a link and the
    // track-click attribute is present.
    if (!isValid) {
        return {
            id: link.id,
            rawAttrs: link.rawAttrs,
            validId: link.id && link.id.trim().length > 0,
            tagName: link.tagName === "a",
            trackingAttr: link.rawAttrs.indexOf("track-click") > -1,
        };
    }else {
        return null;
    }
};

// Build a list of files to lint from the layouts directory.
const filesToLint = buildFileList("../layouts");

const linkLintErrors = {};

for (let i = 0; i < filesToLint.length; i++) {
    const fileToLint = filesToLint[i];
    const html = fs.readFileSync(fileToLint, "utf8");
    const parsedHtml = parse.parse(html);
    const links = parsedHtml.querySelectorAll("a").map(validateTrackingLink)
                  .filter(function(result) { return result !== null });
    if (links.length > 0) {
        linkLintErrors[fileToLint] = links;
    }
}

const filesWithErrors = Object.keys(linkLintErrors);

function createErrorOutput(error) {
    const invalidId = "Link does not have valid id attribute. "
    const invlaidTrackAttr = "Link does not have a the 'track-click' attribute. "
    let msg = "";

    if (!error.validId) {
        msg += invalidId;
    }
    if (!error.trackingAttr) {
        msg += invlaidTrackAttr;
    }
    msg += "\n";
    return msg;
}

if (filesWithErrors.length > 0) {
    console.log(`
RESULT:
    - ${filesToLint.length} files parsed.
    - ${filesWithErrors.length} files have errors.

ERRORS:

${
filesWithErrors.map(function(file) {
const errors = linkLintErrors[file];
return(`
${ file }:
${ errors.map(function(err) {
return(`
<a ${err.rawAttrs}>:
    ${createErrorOutput(err)}
`);
}).join("")
}
`);
}).join("")
}

${[].concat.apply([], Object.values(linkLintErrors)).length} lint errors.
    `);
    process.exit(1);
}else {
    console.log(`
RESULT:
    - ${filesToLint.length} files parsed.
    - 0 errors found.
    `);
    process.exit(0);
}
