package main

import(
	"fmt"
	"io/ioutil"
	"os"
	"time"

	"github.com/BurntSushi/toml"
)

// Function for generating the front matter of an event file
// and the details of the event before the description.
func generateFrontMatter(event Event) string {
	// Parse the start and end dates, then format them.
	startDate, _ := time.Parse("2006-01-02", event.StartDate)
	endDate, _ := time.Parse("2006-01-02", event.EndDate)
	formattedStartDate := startDate.Format("January 02")
	formattedEndDate := endDate.Format("January 02")

	// Grab the year of both the start and end dates to determine
	// if the dates are in different years.
	startYear := startDate.Format("2006")
	endYear := endDate.Format("2006")

	// Assign the date variable. If it is a one day event just show the start date. If the start
	// date is not equal to the end date, display both years with the dates. Otherwise display
	// the start and end date with the end year at the end of the string.
	var date string
	if formattedStartDate == formattedEndDate {
		date = fmt.Sprintf("%s, %s", formattedStartDate, startYear)
	} else if startYear != endYear {
		date = fmt.Sprintf("%s, %s - %s, %s", formattedStartDate, startYear, formattedEndDate, endYear)
	} else {
		date = fmt.Sprintf("%s - %s, %s", formattedStartDate, formattedEndDate, endYear)
	}

	frontMatter := fmt.Sprintf(`---
title: %s
type: page
layout: event-single
calendly_url: "%s"
---
<!--- DO NOT MODIFY -->
<!--- This file is automatically generated by ./tools/eventgen. -->

## Details

<div>
	<i class="fas fa-globe-americas inline-block text-xl"></i>
	<span class="my-0 text-xl">
	    <a href="https://maps.google.com/?q=%s" class="text-blue-500">%s</a>
	</span>
</div>

<div>
	<i class="fas fa-calendar inline-block text-xl"></i>
	<span class="my-0 text-xl">%s</span>
</div>

<div>
	<i class="fas fa-clock inline-block text-xl"></i>
	<span class="my-0 text-xl">%s</span>
</div>

<div>
	<i class="fas fa-ticket-alt inline-block text-xl"></i>
	<span class="my-0 text-xl">%s</span>
</div>`, event.Name, event.CalendlyURL, event.Location, event.Location, date, event.Time, event.Cost)

	return frontMatter
}

// Funcation for getting the pre-defined page content.
func getPageContent(contentType string) string {
	var text string
	switch contentType {
	case "workshop-microsoft":
		content, err := ioutil.ReadFile("./tools/eventgen/snippets/workshop-microsoft.md")
		if err != nil {
			panic(err.Error())
		}

		text = string(content)
	case "kubecon-workshop":
		content, err := ioutil.ReadFile("./tools/eventgen/snippets/kubecon-workshop.md")
		if err != nil {
			panic(err.Error())
		}

		text = string(content)
	default:
		// If the page content doesn't exist panic.
		errMsg := fmt.Sprintf("Content Type %s is not supported", contentType)
		panic(errMsg)
	}

	return text
}

func writeEventFile(event Event) {
	filePath := fmt.Sprintf("./content/events/%s.md", event.URLSlug);
	eventFile, err := os.Create(filePath)
	if err != nil {
		panic(err.Error())
	}

	defer eventFile.Close()

	frontMatterContent := generateFrontMatter(event)
	pageContent := getPageContent(event.ContentType)
	fileContent := fmt.Sprintf("%s\n\n%s", frontMatterContent, pageContent)

	if _, err := eventFile.WriteString(fileContent); err != nil {
		panic(err)
	}
}

type Event struct {
	Type []string
	Name string
	Location string
	StartDate string
	EndDate string
	Description string
	RegistrationURL string
	URLSlug string
	ContentType string
	CalendlyURL string
	Time string
	Cost string
}

type Events struct {
	Events []Event
}

func getEventData() []Event {
	var eventData Events
	filePath := "./data/events.toml"

	if _, err := toml.DecodeFile(filePath, &eventData); err != nil {
		panic(err)
	}

	var filteredEvents []Event
	for _, event := range eventData.Events {
		if event.ContentType != "" {
			filteredEvents = append(filteredEvents, event)
		}
	}

	return filteredEvents
}

func writeEventFiles(events []Event) string {
	for _, event := range events {
		writeEventFile(event)
	}

	return "Event pages have been generated."
}

func main() {

	events := getEventData()
	result := writeEventFiles(events)

	fmt.Printf("%v\n", result)
}
